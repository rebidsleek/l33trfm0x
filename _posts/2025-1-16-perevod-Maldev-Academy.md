---
layout: post
title: "Модуль 1 MalDev Academy на русском"
---

**Модуль 1: Введение в МалварьДев и Архитектура Винды**
  Модуль включает в себя первые 5 частей из оригинального курса MalDev Academy. 
Очень краткое содержание первых двух частей. 
- Ребята рассказывают о разницы между уровнями программирования, а именно лоу и хай лв, я думаю тут каждый догадывается сам о чем идет речь, если ты пиздюк и пишешь на питоне, то ты на хай лв и тебя надо пиздить тапками.
Ты бородатый дед и знаешь как управлять памятью в си, то поздравляю тебе можно доверить написание драйверов.
- Некст вопрос, который поднимают авторы курса, почему стоит выбрать МалварьДев, ответьте сами для себя ок?
- Для меня и для Вас очевидно что существуют разные направления разработки вирусни, ведь и системы затроннутые малварью могут быть разными, так что написания вашего творения под винду и esxi будут немного отличаться.

![]({{ site.baseurl }}/images/m1.jpg)

Третья часть Malvare Academy это софт, это набор молодого бойца.
- Тут советуют ide, а именно visual studio кстати крутой выбор, есть несколько но, например передача телеметрии, так что я бы использовал какой-то neovim и llvm, но это выбор авторов курса, так что кто я такой чтобы их или Вас тех кто за ними пойдет осуждать, правильно никто. 
- x64dbg это даббагер, крутая и удобная тулза для деббага как собственного по, так и чужого, да она частенько используется в реверсе, однако реверс тесно связан с разработкой вредоносов. 
- pe bear - удобен для первоначального анализа структуры PE файлов и поиска подозрительных индикаторов, я бы хотел подушнить тут и рассказать больше, равно как и про деббагер, но пока не буду. 
- Process Hacker 2 это инструмент, который помогает контролировать системные ресурсы, отлаживать программное обеспечение и обнаруживать вредоносные программы. 
- Msfvenom это генератор пейлодов, запилен на основе Метасплойта. Годная вещь, очень годная.
 
![]({{ site.baseurl }}/images/m3.jpg)

Четвертая часть из оригинального курса Структуры и другая база

***Тут авторы пытаютсяобъяснить что такое структура и как ее использовать, а так же передаче аргументов в функцию, тема важная и не раз будет упоминаться в течение всего курса.***

~~Дисклеймер я оставлю ее практически без своих коментов, они там и не требуются по факту, однако, я лично бы расположил эту часть после знакомства с основами и да для понимания, надо знать немного Си.~~

Структуры — это определяемые пользователем типы данных, которые позволяют программисту группировать связанные элементы данных разных типов данных в одну единицу. Структуры могут использоваться для хранения данных, относящихся к тому или иному объекту. Структуры помогают организовать большие объемы связанных данных таким образом, чтобы к ним можно было легко получить доступ и которыми можно было манипулировать. Каждый элемент в структуре называется "членом" или "элементом", эти термины используются взаимозаменяемо в рамках курса. При работе с Windows API часто можно увидеть, что некоторые API требуют заполненную структуру в качестве входных данных, в то время как другие берут объявленную структуру и заполняют ее. Ниже приведен пример THREADENTRY32 структуры, не обязательно понимать, для чего используются члены на этом этапе.
![]({{ site.baseurl }}/images/m4.jpg)

Структуры, используемые в этом курсе, обычно объявляются с использованием ключевого слова typedef для присвоения структуре псевдонима. Например, приведенная ниже структура создается с именем _STRUCTURE_NAME но typedef добавляет два других имени, STRUCTURE_NAME и *PSTRUCTURE_NAME .
![]({{ site.baseurl }}/images/m5.jpg)
Псевдоним STRUCTURE_NAME относится к имени структуры, тогда как указатель на эту структуру. Microsoft обычно использует этот тип. Инициализация структуры PSTRUCTURE_NAME представляет собой префикс P для указания указателя

Инициализация структуры PSTRUCTURE_NAME представляет собой префикс P для указания указателя Инициализация структуры зависит от того, выполняется ли инициализация фактического типа структуры или указателя на структуру. Продолжая предыдущий пример, инициализация структуры происходит так же при использовании _STRUCTURE_NAME или STRUCTURE_NAME , как показано ниже
![]({{ site.baseurl }}/images/m6.jpg)

Иначе обстоит дело при инициализации указателя на структуру, PSTRUCTURE_NAME .
![]({{ site.baseurl }}/images/m7.jpg)

Элементы структуры могут быть инициализированы либо непосредственно через структуру, либо косвенно через указатель на структуру. В приведенном ниже примере структура struct1 имеет два члена, ID и Age, инициализированные напрямую с помощью dot(.).

![]({{ site.baseurl }}/images/m8.jpg)

![]({{ site.baseurl }}/images/m9.jpg)

Другим способом инициализации элементов является использование синтаксиса назначенного инициализатора, где можно указать, какие элементы структуры следует инициализировать.

![]({{ site.baseurl }}/images/m10.jpg)

С другой стороны, доступ к структуре и ее инициализация через указатель осуществляется с помощью стрелки(->).

![]({{ site.baseurl }}/images/m11.jpg)

Оператор стрелки может быть преобразован в формат точки. Например, эквивалентно (*structpointer).ID . То есть, structpointer->ID — это структурный указатель, который разыменовывается и затем получает прямой доступ.


***Стоит так же разобрать методы передачи аргумента в функцию***

Передача по значению — это метод передачи аргументов в функцию, где аргумент является копией значения объекта. Это означает, что когда аргумент передается по значению, значение объекта копируется, и функция может изменить только свою локальную копию значения объекта, а не сам исходный объект.
![]({{ site.baseurl }}/images/m12.jpg)

Передача по ссылке — это метод передачи аргументов в функцию, где аргумент является указателем на объект, а не копией значения объекта. Это означает, что при передаче аргумента по ссылке вместо значения объекта передается адрес памяти объекта. После этого функция может получить доступ к объекту и изменить его напрямую, не создавая локальную копию объекта.
![]({{ site.baseurl }}/images/m13.jpg)

Пятая часть оригинала включает в себя краткое объяснение архитектуры Windows.
В WIndows существует два режима работы, очевидное отличие в правах процесса. 
- В пользовательском режиме работает весь софт и довольно существенная часть известной малвари. 
- В режиме ядра работает сама ось и ее компоненты, а так же сторонние драйвера
Для понимания вот вам картиночка.

![]({{ site.baseurl }}/images/m14.jpg)

- User Processes- Программа/приложение, выполняемое пользователем, например, Блокнот, Google Chrome или Microsoft Word.
- Subsystem DLLs - библиотеки DLL, содержащие функции API, вызываемые пользовательскими процессами. Примером этого может быть kernel32.dll экспорт CreateFile Windows API(WinApi), другими распространенными подсистемными библиотеками DLL являются и user32.dll, ntdll.dll, advapi32.dll.
- Ntdll.dll - DLL, которая является самым низким уровнем, доступным в пользовательском режиме. Это специальная DLL, которая создает переход из пользовательского режима в режим ядра. Её часто называют Native API или NTAPI.
- Executive Kernel - Это ядро Windows, и оно вызывает другие драйверы и модули, доступные в режиме ядра, для выполнения задач. Ядро частично хранится в файле с именем ntoskrnl.exe в разделе "C:\Windows\System32".

На рисунке ниже показан пример приложения, которое создает файл. Пример начинается с того, что пользовательское приложение вызывает функцию WinAPI CreateFile, доступную в kernel32.dll . Kernel32.dll — это критически важная библиотека DLL, которая предоставляет приложениям доступ к WinAPI и поэтому может быть загружена большинством приложений. Затем функция NTAPI CreateFile вызывает свой эквивалент NtCreateFile , который предоставляется через ntdll.dll . Затем Ntdll.dll выполняет ассемблерную инструкцию sysenter (x86) или syscall (x64), которая переводит выполнение в режим ядра. Затем используется функция ядра NtCreateFile, которая вызывает драйверы и модули ядра для выполнения запрошенной задачи.

В этом примере показан поток вызовов функции, происходящий через отладчик. Это делается путем подключения отладчика к двоичному файлу, который создает файл с помощью Windows API CreateFileW.
![]({{ site.baseurl }}/images/m15.jpg)

![]({{ site.baseurl }}/images/m16.jpg)

Стоит сказать, что приложения могут вызывать системные вызовы (т.е. функции NTDLL) напрямую, не проходя через Windows API. WinApi лишь оболочка для native api. Правда на натив апи, нет документации от мелкомягких и использование методов из этого апи сопряжено с различными рисками, но для малварь разраба, эти риски не просто допустимы, а являются часто необходимыми. Так что в будущих модулях будут рассмотрены примеры использования NTAPI.

***Теперь самое вкусное задачи на дом, их надо выполнить до выхода следующей статьи, ждите дня через 3.***
- Найти/скачать/поставить все ПО из начала MS visual Studio хотя бы 17, PE-Bear(https://github.com/hasherezade/pe-bear), Process Hacker 2(https://processhacker.sourceforge.io/downloads.php), MSFvenom(https://www.offsec.com/metasploit-unleashed/msfvenom/)
- Написать на Си или С++, софтинку, которая будет создавать текстовый файл с именем Maldev.txt и записывать строчку "I'm a cool hacker. Soon I'll fuck the whole world and I'll have a cool botnet. fsociety"
Задания вы делаете для себя, а не для меня, мне все равно получится у вас это или нет. 

![]({{ site.baseurl }}/images/m17.jpg)

Спасибо всем кто продрался через первые модули с техинфой, дальше будет сложнее и интереснее, плюс я буду пытаться сгладить душноту, там где это вообще возможно.
![]({{ site.baseurl }}/images/m1.gif)

Если тебе понравилось, подпишись на канал https://t.me/l33trfm0x 
